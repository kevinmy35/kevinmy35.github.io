{"meta":{"title":"neu machine learning","subtitle":"machine learning notes","description":"a space where anyone can discuss the machine learning including deep learning","author":"Mouye","url":"http://neuml.com"},"posts":[{"title":"现代优化计算方法-遗传算法解决TSP问题","slug":"现代优化计算方法-遗传算法解决TSP问题","date":"2017-12-04T12:47:42.000Z","updated":"2017-12-04T05:05:05.523Z","comments":true,"path":"2017/12/04/现代优化计算方法-遗传算法解决TSP问题/","link":"","permalink":"http://neuml.com/2017/12/04/现代优化计算方法-遗传算法解决TSP问题/","excerpt":"","text":"遗传算法解决TSP问题用遗传算法(GA)解决TSP问题，也就是第一个大作业的简单版本。数据来源tsplib中的aat48，48个城市，对称型TSP问题，最优解为10628。下面为java代码和详细注释：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292package genetic_alogrithms;import java.io.BufferedReader;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStreamReader;public class GA &#123; private int POPsize; //种群大小 private int CITYnum; //城市数量 private int Iteration; //迭代次数 private double [][] Distance; //城市间的距离矩阵 private int [] Bestsolution; //最优解数组 private double Bestlength; //最佳长度 private double [] Fitness; // 适应度 private int[][] Fatherpop; //父代种群 private int[][] Offspringpop; //子代种群 private double[] Pa; //累计概率 private double Pc; //交叉概率 private double Pm; //变异概率 private int t; //当前的代数 private int bestT; //最佳路径出现的代数 // 构造函数 public GA(int POPsize,int CITYnum,int Iteration,double Pc,double Pm)&#123; this.POPsize = POPsize; this.CITYnum = CITYnum; this.Iteration = Iteration; this.Pc = Pc; this.Pm = Pm; &#125; // 读取数据 public void read_data(String filename) throws IOException&#123; int[] x = new int[CITYnum]; //定义x坐标 int[] y = new int[CITYnum]; //定义y坐标 Distance = new double[CITYnum][CITYnum]; //定义距离矩阵 String strbuff; @SuppressWarnings(\"resource\") BufferedReader data = new BufferedReader(new InputStreamReader(new FileInputStream(filename))); //读取数据文件 // 获得每个城市的坐标 for(int i=0;i&lt;CITYnum;i++)&#123; strbuff = data.readLine(); String[] s = strbuff.split(\" \"); //数据之间有空格 x[i] = Integer.valueOf(s[1]); //读取x坐标 y[i] = Integer.valueOf(s[2]); //读取y坐标 &#125; // 计算距离获得距离矩阵 for(int i=0;i&lt;CITYnum;i++)&#123; for(int j=0;j&lt;CITYnum;j++)&#123; double Dij = Math.sqrt(((Math.pow(x[i]-x[j], 2))+(Math.pow(y[i]-y[j], 2)))/10.0); //距离计算公式 Distance[i][j] = Dij; &#125; &#125; // 测试数据是否读入// for(int i=0;i&lt;48;i++)&#123;// for(int j=0;j&lt;48;j++)&#123;// System.out.println(Distance[i][j]);// &#125;// &#125; &#125; // 初始化种群 public void initGroup()&#123; // 初始化 Fatherpop = new int[POPsize][CITYnum]; Offspringpop = new int[POPsize][CITYnum]; Bestsolution = new int[CITYnum]; Fitness = new double[POPsize]; Pa = new double[POPsize]; Bestlength = Integer.MAX_VALUE; t = 0; int i,j,k; for(i=0;i&lt;POPsize;i++)&#123; for(j=0;j&lt;CITYnum;)&#123; Fatherpop[i][j] = (int) (Math.random()*48); //父代随机赋值[0,48) // 判断是否有重复元素 for(k=0;k&lt;j;k++)&#123; if(Fatherpop[i][k]==Fatherpop[i][j])&#123; break; &#125; &#125; if(k==j)&#123; j++; &#125; &#125; &#125; &#125; // 计算出每个染色体所代表的距离数值 public double getDistance(int[] chromosome)&#123; double length = 0.0; for(int i=1;i&lt;CITYnum;i++)&#123; length += Distance[chromosome[i-1]][chromosome[i]]; //得到中间城市的距离 &#125; length += Distance[chromosome[CITYnum-1]][chromosome[0]]; //首尾城市的距离 return length; &#125; // 得到每个染色体的适应度数组 public void getFitness()&#123; for(int i=0;i&lt;POPsize;i++)&#123; Fitness[i] = getDistance(Fatherpop[i]); &#125; &#125; // 计算累积概率 public void getPa()&#123; double TotalFitness = 0; //定义种群的总的适应度 double[] fit = new double[POPsize]; // 计算出总适应度 for(int i=0;i&lt;POPsize;i++)&#123; fit[i] = 10.0/Fitness[i]; TotalFitness += fit[i]; &#125; // 计算累积概率 Pa[0] = fit[0]/TotalFitness; for(int j=1;j&lt;POPsize;j++)&#123; Pa[j] = (fit[j]/TotalFitness) + Pa[j-1]; &#125; &#125; // 复制染色体 public void copyChromosome(int a,int b)&#123; for(int i=0;i&lt;CITYnum;i++)&#123; Offspringpop[a][i] = Fatherpop[b][i]; &#125; &#125; // 轮盘赌选择 public void STW()&#123; int selectID; //选中的父代染色体编号 int i ,j; //i为子代染色体编号 for(i=0;i&lt;POPsize;i++)&#123; double p = Math.random(); for(j=0;j&lt;POPsize;j++)&#123; if(p &lt;= Pa[j])&#123; break; &#125; &#125; selectID = j; copyChromosome(i,selectID); //把父代选中的染色体复制给子代 &#125; &#125; // 选择最好的个体 public void selectBest()&#123; double best; int bestID = 0; // 获得最好个体的适应度 best = Fitness[0]; for(int i=0;i&lt;POPsize;i++)&#123; if(best&gt;Fitness[i])&#123; best = Fitness[i]; bestID = i; &#125; &#125; // 获得出现最好的染色体出现的代数 if(Bestlength&gt;best)&#123; Bestlength = best; bestT = t; &#125; // 获得最佳的染色体 for(int i=0;i&lt;CITYnum;i++)&#123; Bestsolution[i] = Fatherpop[bestID][i]; &#125; &#125; // 交叉算子 public void crossover(int a,int b)&#123; int rank1,rank2,i,j,flag,k; rank1 = (int) (Math.random()*48); rank2 = (int) (Math.random()*48); int[] chro1 = new int[CITYnum]; int[] chro2 = new int[CITYnum]; // 得到chro1[] // 得到染色体b中和染色体a的(rank1)位置及其以后位置不相同的信息，一共有(rank1)个 for(k=0,j=0;k&lt;CITYnum;k++)&#123; chro1[j] = Offspringpop[b][k]; for(i=rank1;i&lt;CITYnum;i++)&#123; if(Offspringpop[a][i] == chro1[j])&#123; break; &#125; &#125; if(i == CITYnum)&#123; j++; &#125; &#125; // 将染色体a的rank1位置及其以后位置给chro1[] flag = rank1; for(i=flag,j=flag;j&lt;CITYnum;i++,j++)&#123; chro1[j] = Offspringpop[a][i]; &#125; // 得到chro2[] flag = rank2; // 得到a染色体不同于b染色体前rank2个的信息，为(rank2)个 for(k=0,j=0;k&lt;CITYnum;k++)&#123; chro2[j] = Offspringpop[a][k]; // 确保每个编码不相同 for(i=flag;i&lt;CITYnum;i++)&#123; if(Offspringpop[b][i] == chro2[j])&#123; break; &#125; &#125; if (i == CITYnum)&#123; j++; &#125; &#125; // 将前b染色体中前rank2中的信息给到chro1[]中 for(i=flag,j=flag;j&lt;CITYnum;j++,i++)&#123; chro2[i] = Offspringpop[b][j]; &#125; // 得到交叉完成后的染色体 for(i=0;i&lt;CITYnum;i++)&#123; Offspringpop[a][i] = chro1[i]; Offspringpop[b][i] = chro2[i]; &#125; &#125; // 随机交换型变异 public void mutation(int a)&#123; int cnt,rank1,rank2,temp; cnt = (int)(Math.random()*48); //交换次数 for(int i=0;i&lt;cnt;i++)&#123; rank1 = (int)(Math.random()*48); rank2 = (int)(Math.random()*48); while(rank1 == rank2)&#123; rank2 = (int)(Math.random()*48); &#125; // 交换 temp = Offspringpop[a][rank1]; Offspringpop[a][rank1] = Offspringpop[a][rank2]; Offspringpop[a][rank2] = temp; &#125; &#125; // 进化（遗传+交叉+变异） public void evolution()&#123; int i; double p; selectBest(); //得到最好的路径、最好的长度、出现最好路径的代数 STW(); //轮盘赌选择父代，获取子代 for(i=0;i&lt;POPsize;i=i+2)&#123; p = Math.random(); // 是否交叉 if(p&lt;Pc)&#123; crossover(i,i+1); &#125; p = Math.random(); // 是否变异 if(p&lt;Pm)&#123; mutation(i); &#125; p = Math.random(); if(p&lt;Pm)&#123; mutation(i+1); &#125; &#125; &#125; // 遗传算法 public void ga()&#123; initGroup(); //初始化种群 getFitness(); //得到种群适应度 getPa(); //得到累积概率 for(t=0;t&lt;Iteration;t++)&#123; evolution(); //进化 for(int i=0;i&lt;POPsize;i++)&#123; for(int j=0;j&lt;CITYnum;j++)&#123; Fatherpop[i][j] = Offspringpop[i][j]; //将子代的信息给父代，准备下一次进化 &#125; &#125; getFitness(); //得到新一代种群的适应度 getPa(); //得到新一代种群的累积概率 &#125; System.out.println(\"最佳长度出现的代数：\"+bestT); System.out.println(\"最佳长度：\"+Bestlength); System.out.print(\"最佳路径：\"); // 打印最佳路径 for(int i=0;i&lt;CITYnum;i++)&#123; System.out.print(Bestsolution[i]+\" \"); &#125; &#125; public static void main(String[] args) throws IOException &#123; GA g =new GA(240,48,5000,0.9,0.2); //构造GA类 g.read_data(\"/home/mouye/aat48.txt\"); //读取数据 g.ga(); //调用遗传算法 &#125;&#125;","raw":null,"content":null,"categories":[],"tags":[{"name":"遗传算法","slug":"遗传算法","permalink":"http://neuml.com/tags/遗传算法/"},{"name":"TSP问题","slug":"TSP问题","permalink":"http://neuml.com/tags/TSP问题/"}]},{"title":"现代优化计算方法--背包问题","slug":"blog","date":"2017-11-22T22:42:39.000Z","updated":"2017-11-22T14:51:20.549Z","comments":true,"path":"2017/11/23/blog/","link":"","permalink":"http://neuml.com/2017/11/23/blog/","excerpt":"背包问题上次用的Java写的，存在很大的问题。这次用Python重新写了一下。","text":"背包问题上次用的Java写的，存在很大的问题。这次用Python重新写了一下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import xlrdimport numpy as np from numpy import float64 ''' read excel 读取价值和重量的数据'''cnt = 0data = xlrd.open_workbook('/home/mouye/1.xlsx') table = data.sheets()[0] nrows = table.nrowsncols = table.ncolscapacity = np.array([5555])w=np.arange(nrows,dtype=float64).reshape(1,nrows)v=np.arange(nrows,dtype=float64).reshape(1,nrows)c=np.zeros(nrows).reshape(1,nrows)vw=np.arange(nrows,dtype=float64).reshape(1,nrows)tags=np.arange(nrows).reshape(1,nrows)''' get value/weight 性价比'''for i in range(nrows): w[0,i] = table.cell(i,0).valuefor i in range(nrows): v[0,i] = table.cell(i,1).value vw[0,i] = v[0,i]/w[0,i] tags[0,i] = i''' sort them 冒泡排序'''for i in range(nrows): for j in range(i+1,nrows): if vw[0,i]&lt;vw[0,j]: t=vw[0,i] vw[0,i]=vw[0,j] vw[0,j]=t tag = tags[0,i] tags[0,i] = tags[0,j] tags[0,j] = tag''' 贪心算法 '''for i in range(nrows): if capacity[0]&gt;=0: m=tags[0,i] capacity[0]-=w[0,m] c[0,tags[0,i]]=1 cnt = cnt+1 if capacity[0]&lt;0: c[0,tags[0,cnt-1]]=0 capacity[0]=capacity[0]+w[0,tags[0,cnt-1]]c=c.reshape(nrows,1)b=np.dot(v,c)r=np.dot(w,c)print rprint b''' local search '''capacity = np.array([5555])for item in range(10000): x=np.random.randint(0,9999) c[x,0]=1 c[x+1,0]=0 l=np.dot(v,c) r=np.dot(w,c) if r[0,0]&lt;=capacity[0]: if l[0,0]&gt;b[0,0]: b[0,0]=l[0,0]print b[0,0]","raw":null,"content":null,"categories":[],"tags":[{"name":"背包问题","slug":"背包问题","permalink":"http://neuml.com/tags/背包问题/"},{"name":"Python","slug":"Python","permalink":"http://neuml.com/tags/Python/"}]},{"title":"《现代优化计算方法》听课笔记——第二课","slug":"现代优化计算方法听课笔记——第二课","date":"2017-11-10T23:00:30.000Z","updated":"2017-11-10T16:08:25.275Z","comments":true,"path":"2017/11/11/现代优化计算方法听课笔记——第二课/","link":"","permalink":"http://neuml.com/2017/11/11/现代优化计算方法听课笔记——第二课/","excerpt":"","text":"绪论 1.旅行商问题（traveling salesman problem,TSP) 2.约束机器排序（capacitated machine scheduling）问题 3.时间复杂度分析 4.领域的概念","raw":null,"content":null,"categories":[],"tags":[{"name":"现代优化计算方法","slug":"现代优化计算方法","permalink":"http://neuml.com/tags/现代优化计算方法/"},{"name":"听课笔记","slug":"听课笔记","permalink":"http://neuml.com/tags/听课笔记/"}]},{"title":"《现代优化计算方法》听课笔记——第一课","slug":"现代优化计算方法听课笔记——第一课","date":"2017-11-08T21:14:34.000Z","updated":"2017-11-22T15:04:16.412Z","comments":true,"path":"2017/11/09/现代优化计算方法听课笔记——第一课/","link":"","permalink":"http://neuml.com/2017/11/09/现代优化计算方法听课笔记——第一课/","excerpt":"课程概况\n\n任课教师系统工程研究所：王大志Email:wangdazhi1@ise.neu.edu.cnTel:18002455565\n课程结构一、绪论二、禁忌搜索算法三、遗传算法四、模拟退火算法五、粒子群优化算法六、蚁群优化算法\n参考书籍1.《现代优化计算方法（第二版）》 刑文训 谢金星 编著  清华大学出版社（几乎绝版，淘宝价格200左右，所以请各位同学自行解决）2.《智能优化方法》 汪定伟 编著  高等教育出版社  淘宝链接 \n考评形式课程出勤：20%平时练习：20%项目报告：60%（初步定在18周周五之前上交）","text":"课程概况 任课教师系统工程研究所：王大志Email:wangdazhi1@ise.neu.edu.cnTel:18002455565 课程结构一、绪论二、禁忌搜索算法三、遗传算法四、模拟退火算法五、粒子群优化算法六、蚁群优化算法 参考书籍1.《现代优化计算方法（第二版）》 刑文训 谢金星 编著 清华大学出版社（几乎绝版，淘宝价格200左右，所以请各位同学自行解决）2.《智能优化方法》 汪定伟 编著 高等教育出版社 淘宝链接 考评形式课程出勤：20%平时练习：20%项目报告：60%（初步定在18周周五之前上交） 绪论 0-1背包问题（knapsack problem)Java代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package knapsack;//现有背包容量为200kg//物品的重量和价值如下：// 20kg--20// 25kg--20// 35kg--50// 40kg--50// 50kg--45// 60kg--45// 70kg--55public class GreedyAlgorithm &#123; public double[] weight = new double[] &#123;20, 25, 35, 40, 50, 60, 70&#125;;//定义重量的数组 public double[] value = new double[] &#123;20, 20, 50, 50, 45, 45, 55&#125;;//定义价值的数组 public int capacity = 200;//定义背包容量 public void knapsack1()&#123; int size = weight.length; //获取重量数组的长度 int[] tags = new int[size];//定义顺序数组 double[] vw = new double[size];//定义性价比数组 for(int i=0;i&lt;size;i++)&#123; vw[i] = value[i]/weight[i];//算出性价比 tags[i] = i;//得到初始的排序 &#125; //冒泡排序，得到性价比从小到大的数组 for(int i=0;i&lt;size;i++)&#123; for(int j=i+1;j&lt;size;j++)&#123; if(vw[i]&lt;vw[j])&#123; double change =vw[i]; vw[i] = vw[j]; vw[j] = change; //得到按照性价比大小的排序 int tag = tags[i]; tags[i] = tags[j]; tags[j] = tag; &#125; &#125; &#125; //贪心算法 for(int i=0;i&lt;size;i++)&#123; if(capacity&gt;=0)&#123; System.out.println(\"添加物品:\" + weight[tags[i]]);//以重量作为标注进行输出 capacity -= weight[tags[i]]; &#125; if(capacity&lt;0)&#123; capacity+=weight[tags[i]]; System.out.println(\"删除物品：\"+weight[tags[i]]); &#125; &#125; System.out.print(capacity); &#125; public static void main(String[] args) &#123; GreedyAlgorithm gda = new GreedyAlgorithm(); gda.knapsack1(); &#125;&#125;","raw":null,"content":null,"categories":[],"tags":[{"name":"现代优化计算方法","slug":"现代优化计算方法","permalink":"http://neuml.com/tags/现代优化计算方法/"},{"name":"听课笔记","slug":"听课笔记","permalink":"http://neuml.com/tags/听课笔记/"}]},{"title":"Deep Learning Framework","slug":"Deep-Learning-framework","date":"2017-10-16T00:00:00.000Z","updated":"2017-10-18T12:06:02.805Z","comments":true,"path":"2017/10/16/Deep-Learning-framework/","link":"","permalink":"http://neuml.com/2017/10/16/Deep-Learning-framework/","excerpt":"深度学习主流框架深度学习作为机器学习一个重要分支，被大家普遍认为是通往人工智能的一个重要途径（其实是一门玄学）。在当今这个年代，去路上随便找一个人就能随口飙出几个深度学习相关的术语，手写几层神经网络。你说深度学习有多火？今天小编my向大家简单介绍一下深度学习的几个主流框架。","text":"深度学习主流框架深度学习作为机器学习一个重要分支，被大家普遍认为是通往人工智能的一个重要途径（其实是一门玄学）。在当今这个年代，去路上随便找一个人就能随口飙出几个深度学习相关的术语，手写几层神经网络。你说深度学习有多火？今天小编my向大家简单介绍一下深度学习的几个主流框架。 TensorFlow谷歌开源项目，是一个采用数据流图（data flow graphs），用于数值计算的开源软件库。有谷歌这个巨佬撑腰，选它作为框架总没错。 MXNet亚马逊指定官方深度学习平台，亚马逊公司作为后台，使用人数逐渐增多，各位大神都说前景比较好，易于部署，适合做工程的人使用。 Caffe(2)caffe是一个清晰，可读性高，快速的深度学习框架。作者是贾扬清，加州大学伯克利的ph.D，现就职于Facebook。前不久facebook开源了caffe2。caffe的源码适合阅读学习，总体来说适合搞科研的人使用。 Keras非常容易上手的一个深度学习框架，后台是调用TensorFlow来进行运算的。对Python支持得非常好，小编正在努力学习中。 深度学习的框架还有PyTorch,CNTK,Theano(近日宣布不再更新)等，这些框架小编不太熟悉，就不一一介绍了，感兴趣的朋友可以自行谷歌。小编正在学习Keras中，接下来的博文都将记录我学习中遇到的问题和自己的感悟，希望感兴趣的朋友能和小编多多交流，共同进步。","raw":null,"content":null,"categories":[],"tags":[{"name":"DeepLearning","slug":"DeepLearning","permalink":"http://neuml.com/tags/DeepLearning/"},{"name":"Frame","slug":"Frame","permalink":"http://neuml.com/tags/Frame/"}]},{"title":"Machine Learning Summary","slug":"machine-learning-summary","date":"2017-10-10T10:30:48.000Z","updated":"2017-10-18T12:29:48.370Z","comments":true,"path":"2017/10/10/machine-learning-summary/","link":"","permalink":"http://neuml.com/2017/10/10/machine-learning-summary/","excerpt":"2017年是公认的人工智能元年。随着计算能力和算法性能的提高，传统机器学习得到了快速的发展，在这里小编my将为大家简单介绍一下机器学习以及如何快速入门。\n1. 什么是机器学习?\nArthur samuel(1959)：Machine learning is a field of computer science that gives computers the ability to learn without being explicitly programmed.\nTom mithell(1998):A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P if its performance at tasks in T, as measured by P, improves with experience E.（吴恩达在coursea上曾吐槽他觉得这个定义仅仅是为了押韵）\n","text":"2017年是公认的人工智能元年。随着计算能力和算法性能的提高，传统机器学习得到了快速的发展，在这里小编my将为大家简单介绍一下机器学习以及如何快速入门。 1. 什么是机器学习? Arthur samuel(1959)：Machine learning is a field of computer science that gives computers the ability to learn without being explicitly programmed. Tom mithell(1998):A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P if its performance at tasks in T, as measured by P, improves with experience E.（吴恩达在coursea上曾吐槽他觉得这个定义仅仅是为了押韵） 2.机器学习的分类 监督学习（supervised learning）线性回归（linear regression)逻辑斯蒂回归（logistic regression)神经网络（neural network)SVMs 半监督学习（semi-supervised learning)自训练算法 (self training)生成模型 (generative models)图论方法 (graph-basedmethods） 无监督学习（unsupervised learning)K-meansPCA 其他Reinforcement learningDNNRNN/LSTMCNNReconmender systemsDeep Reinforcement learning 3.书籍和相关教学视频推荐 书籍 国内：这两本书是国内真正懂机器学习的人推出的经典之作，如果你没能力看外文原版书籍，又不能忍受翻译过来的死板带来的不快，那小编强烈推荐这两本书来进行入门 《统计学习方法》-李航 《机器学习》-周志华（西瓜书） 国外：《pattern recognition and machine learning》业内简称PRML，有中文翻译版本，但不是官方授权翻译。中文翻译版本是哈工大某实验室的一位研究生所翻译的。本书是经典之作，推荐阅读 教学视频 首推吴恩达的机器学习视频：coursea地址：coursea上的机器学习视频B站地址：B站机器学习视频当然网易云公开课也有吴恩达的机器学习公开课，但是年份有点久远，这里小编就不贴地址的，需要的同学自行搜索。 其次推荐台湾大学李宏毅的机器学习视频，浓浓的台湾腔，把课讲得十分有趣形象但也不缺严谨性：台湾大学机器学习视频","raw":null,"content":null,"categories":[],"tags":[{"name":"Summary","slug":"Summary","permalink":"http://neuml.com/tags/Summary/"},{"name":"MachineLearning","slug":"MachineLearning","permalink":"http://neuml.com/tags/MachineLearning/"}]},{"title":"Hello Machine Learning","slug":"hello-world","date":"2017-10-09T00:00:00.000Z","updated":"2017-10-18T12:27:22.431Z","comments":true,"path":"2017/10/09/hello-world/","link":"","permalink":"http://neuml.com/2017/10/09/hello-world/","excerpt":"","text":"大家好，这里是东B大学自动化系的一名普通学生。希望大家喜欢我的博客，欢迎各路大神批评指正。","raw":null,"content":null,"categories":[],"tags":[{"name":"Introduction","slug":"Introduction","permalink":"http://neuml.com/tags/Introduction/"}]}]}